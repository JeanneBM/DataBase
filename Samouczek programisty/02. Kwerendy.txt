SELECT * FROM genre WHERE name = 'Rock' AND genreid < 20;

SQL nie zwraca uwagi na wielkość liter:
"SELECT * FROM genre WHERE genreid = 1;" 
to samo inaczej: "SELECT * frOM geNRe wherE GenReID = 1;"


sqlite> .schema Invoice
CREATE TABLE [Invoice]
(
    [InvoiceId] INTEGER  NOT NULL,
    [CustomerId] INTEGER  NOT NULL,
    [InvoiceDate] DATETIME  NOT NULL,
    [BillingAddress] NVARCHAR(70),
    [BillingCity] NVARCHAR(40),
    [BillingState] NVARCHAR(40),
    [BillingCountry] NVARCHAR(40),
    [BillingPostalCode] NVARCHAR(10),
    [Total] NUMERIC(10,2)  NOT NULL,
    CONSTRAINT [PK_Invoice] PRIMARY KEY  ([InvoiceId]),
    FOREIGN KEY ([CustomerId]) REFERENCES [Customer] ([CustomerId])
                ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE UNIQUE INDEX [IPK_Invoice] ON [Invoice]([InvoiceId]);
CREATE INDEX [IFK_InvoiceCustomerId] ON [Invoice] ([CustomerId]);


AND/OR:
Słowo kluczowe AND ma wyższy priorytet niż OR. Oznacza to, że warunki pomiędzy AND wykonywane są wcześniej niż OR.
SELECT * FROM invoice WHERE billingcity = 'Dublin' AND total > 5 OR billingcity = 'Boston' AND total < 3 AND total > 1;
to samo inaczej:
SELECT * FROM invoice WHERE (billingcity = 'Dublin' AND total > 5) OR (billingcity = 'Boston' AND total < 3 AND total > 1);

Łączenie warunków:
Nawiasy zmieniają zapytanie:
x OR y AND z
Bez zmian:
x OR (y AND z)
Zmiana kolejności wykonywania operacji:
(x OR y) AND z

Negacja warunków:
(NOT x) OR y = NOT x OR y
Zmiana warunku:
NOT (x OR y)


NULL:
SELECT * FROM invoice WHERE billingstate IS NOT NULL AND billingcountry != 'USA';


Wybór kolumn:
SELECT invoicedate,billingcity,total FROM invoice WHERE billingcountry = 'Poland';


Daty:
SELECT billingcountry FROM invoice WHERE total < 10 AND invoicedate > '2013-12-05 00:00:00' AND invoicedate < '2013-12-09 00:00:00';

SELECT billingcity, billingcountry FROM invoice WHERE (billingstate IS NULL AND total > 17) OR (total < 1 AND billingstate IS NOT NULL
 AND invoicedate > '2013-09-20 00:00:00');

SELECT * FROM invoice WHERE billingcountry = 'Poland' AND invoicedate > '2012-05-26';

SELECT firstname FROM employee WHERE birthdate BETWEEN '1960-' AND '1970-';


Znaki specjalne:
SELECT * FROM album WHERE title LIKE '%''%';


Porównywanie łańcuchów:
SELECT * FROM invoice WHERE billingcountry > 'A' AND billingcountry < 'C';


BETWEEN:
SELECT * FROM invoice WHERE total BETWEEN 10.91 AND 11.96;


LIKE:
% – oznacza dowolną liczbę znaków,
_ – oznacza jeden znak.

SELECT * FROM invoice WHERE billingcountry LIKE '%land'; - tylko te co kończą się na "land"
SELECT * FROM invoice WHERE billingcountry LIKE '%land%'; - zawierają ciąg znaków "land"

ESCAPE:
żeby _  % były traktowane dosłownie 
SELECT * FROM track WHERE name LIKE '%e%%' ESCAPE 'e';


IS NULL:
SELECT * FROM invoice WHERE billingstate IS NULL;


IN:
Użycie IN jest tożsame odpowiedniej liczbie warunków połączonych OR.
SELECT * FROM invoice WHERE billingcountry = 'USA' AND billingstate IN ('CA', 'TX'); - znajdzie wszystkie USA w kolumnach CA i TX


LIMIT:
SELECT * FROM genre LIMIT 5; - tylko 5 wierszy


OFFSET:
SELECT * FROM genre LIMIT 5 OFFSET 10; - pominie pierwsze 10 wierszy
SELECT * FROM genre LIMIT 5 OFFSET 10;


DISTINCT:
Odfiltrowanie powielonych wierszy.
SELECT DISTINCT billingcountry FROM invoice;
SELECT DISTINCT billingcountry,billingcity FROM invoice; - odfiltruje wyniki, gdzie w obu przypadkach jest powielone jednocześnie

DISTINCT wartości NULL traktuje jako równe sobie.


ORDER BY. Sortowanie:
Rosnąco: SELECT name FROM genre ORDER BY name; lub  SELECT name FROM genre ORDER BY name ASC; 
ASC można pominąć - z założenia jest rosnąco
Malejąco:  SELECT name FROM genre ORDER BY name DESC;
Po wielu kolumnach: SELECT DISTINCT billingcountry, billingstate FROM invoice ORDER BY billingcountry DESC, billingstate;


AS. Aliasy dla kolumn:
zmiana nazwy kolumn pokazywanych w wynku.
SELECT genreid AS id, name AS 'genre name' FROM genre LIMIT 5;
 
 
Scalanie wyników wielu zapytań:
UNION ALL:
SELECT name AS xxx FROM genre UNION ALL SELECT DISTINCT billingcity FROM invoice ORDER BY xxx LIMIT 10;
- zwraca w jednej kolumnie o nazwie xxx wszystkie wartości kolumny name z tabeli genre połączone z unikalnymi wartościami kolumny 
 billingcity z tabeli invoice 

Podzapytania, które są scalane przy użyciu wyrażeń UNION albo UNION ALL muszą zwracać tę samą liczbę kolumn o tym samym typie.
Wyrażenia LIMIT i ORDER BY mogą być użyte tylko do scalonych zapytań. Nie możesz ich użyć wewnątrz zapytań, które są scalane.

UNION a UNION ALL:
Oba wyrażenia służą do scalenia wyników wielu zapytań. Jednak UNION zwróci unikalną listę wierszy, kiedy UNION ALL zwróci wszystkie 
wiersze i w wyniku mogą być duplikaty.

UNION ALL do scalania dwóch zapytań:
SELECT genreid, name AS xxx FROM genre UNION ALL SELECT invoiceid,billingcity FROM invoice UNION SELECT albumid, title FROM album
 ORDER BY xxx LIMIT 10;


FUNKCJE:

Funkcja operująca na tabeli:
SELECT LENGTH(billingstate) FROM invoice LIMIT 5;

SELECT DISTINCT LENGTH(billingstate) FROM invoice;
wynik:
[puste]
2
6
3
Wyniki tego zapytania można zrozumieć jako: w tabeli invoice istnieją wiersze, których wartość kolumny billingstate jest pusta, ma 
długość 2, 6 albo 3.

Wiele funkcji w wielu miejscach:
SELECT DISTINCT LENGTH(billingstate) FROM invoice ORDER BY LENGTH(billingstate);
z aliasem lepiej:
SELECT DISTINCT LENGTH(billingstate) AS len FROM invoice ORDER BY len;

Łączenie funkcji:
SELECT MAX(LENGTH(billingstate)) FROM invoice;
jeden wiersz, zawierający maksymalną wartość zwróconą przez funkcję LENGTH

Inne przykładowe:
ABS – zwraca wartość bezwzględną przyjmowanego argumentu,
LENGTH – zwraca długość łańcucha znaków,
LOWER – zwraca kopię łańcucha znaków przekazanego jako parametr, w którym wszystkie litery zamienione są na małe,
RANDOM – zwraca losową liczbę całkowitą,
SUBSTR3 – SUBSTR(x, y, z) pobiera podzbiór znaków parametru x od litery y o długości z. Parametr z może być pominięty, wtedy funkcja zwraca podzbiór znaków od znaku y do końca. Pierwsza litera ma indeks 1,
TRIM – usuwa spacje z obu stron przekazanego parametru,
UPPER – funkcja działa podobnie jak LOWER, tym razem zwracany łańcuch znaków składa się z wielkich liter.

Grupowanie GROUP BY:
SELECT billingcountry, MAX(total) FROM invoice GROUP BY billingcountry LIMIT 5;
zwróci pięć wierszy. Każdy z nich zawierał będzie kraj i największą wartość faktury dla danego kraju

