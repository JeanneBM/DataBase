SELECT * FROM genre WHERE name = 'Rock' AND genreid < 20;

SQL nie zwraca uwagi na wielkość liter:
"SELECT * FROM genre WHERE genreid = 1;" 
to samo inaczej: "SELECT * frOM geNRe wherE GenReID = 1;"


sqlite> .schema Invoice
CREATE TABLE [Invoice]
(
    [InvoiceId] INTEGER  NOT NULL,
    [CustomerId] INTEGER  NOT NULL,
    [InvoiceDate] DATETIME  NOT NULL,
    [BillingAddress] NVARCHAR(70),
    [BillingCity] NVARCHAR(40),
    [BillingState] NVARCHAR(40),
    [BillingCountry] NVARCHAR(40),
    [BillingPostalCode] NVARCHAR(10),
    [Total] NUMERIC(10,2)  NOT NULL,
    CONSTRAINT [PK_Invoice] PRIMARY KEY  ([InvoiceId]),
    FOREIGN KEY ([CustomerId]) REFERENCES [Customer] ([CustomerId])
                ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE UNIQUE INDEX [IPK_Invoice] ON [Invoice]([InvoiceId]);
CREATE INDEX [IFK_InvoiceCustomerId] ON [Invoice] ([CustomerId]);


AND/OR:
Słowo kluczowe AND ma wyższy priorytet niż OR. Oznacza to, że warunki pomiędzy AND wykonywane są wcześniej niż OR.
SELECT * FROM invoice WHERE billingcity = 'Dublin' AND total > 5 OR billingcity = 'Boston' AND total < 3 AND total > 1;
to samo inaczej:
SELECT * FROM invoice WHERE (billingcity = 'Dublin' AND total > 5) OR (billingcity = 'Boston' AND total < 3 AND total > 1);

Łączenie warunków:
Nawiasy zmieniają zapytanie:
x OR y AND z
Bez zmian:
x OR (y AND z)
Zmiana kolejności wykonywania operacji:
(x OR y) AND z

Negacja warunków:
(NOT x) OR y = NOT x OR y
Zmiana warunku:
NOT (x OR y)


NULL:
SELECT * FROM invoice WHERE billingstate IS NOT NULL AND billingcountry != 'USA';


Wybór kolumn:
SELECT invoicedate,billingcity,total FROM invoice WHERE billingcountry = 'Poland';


Daty:
SELECT billingcountry FROM invoice WHERE total < 10 AND invoicedate > '2013-12-05 00:00:00' AND invoicedate < '2013-12-09 00:00:00';

SELECT billingcity, billingcountry FROM invoice WHERE (billingstate IS NULL AND total > 17) OR (total < 1 AND billingstate IS NOT NULL
AND invoicedate > '2013-09-20 00:00:00');

SELECT * FROM invoice WHERE billingcountry = 'Poland' AND invoicedate > '2012-05-26';

SELECT firstname FROM employee WHERE birthdate BETWEEN '1960-' AND '1970-';


Znaki specjalne:
SELECT * FROM album WHERE title LIKE '%''%';


Porównywanie łańcuchów:
SELECT * FROM invoice WHERE billingcountry > 'A' AND billingcountry < 'C';


BETWEEN:
SELECT * FROM invoice WHERE total BETWEEN 10.91 AND 11.96;


LIKE:
% – oznacza dowolną liczbę znaków,
_ – oznacza jeden znak.

SELECT * FROM invoice WHERE billingcountry LIKE '%land'; - tylko te co kończą się na "land"
SELECT * FROM invoice WHERE billingcountry LIKE '%land%'; - zawierają ciąg znaków "land"

ESCAPE:
żeby _  % były traktowane dosłownie 
SELECT * FROM track WHERE name LIKE '%e%%' ESCAPE 'e';


IS NULL:
SELECT * FROM invoice WHERE billingstate IS NULL;


IN:
Użycie IN jest tożsame odpowiedniej liczbie warunków połączonych OR.
SELECT * FROM invoice WHERE billingcountry = 'USA' AND billingstate IN ('CA', 'TX'); - znajdzie wszystkie USA w kolumnach CA i TX





